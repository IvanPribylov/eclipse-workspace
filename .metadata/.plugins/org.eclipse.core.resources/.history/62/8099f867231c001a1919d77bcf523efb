package com.copyright.rup.qa.rfe.tests.steps;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import com.copyright.rup.common.logging.RupLogUtils;
import com.copyright.rup.qa.common.ui.support.UiSupport;
import com.copyright.rup.qa.rfe.tests.domain.SearchResult;
import com.copyright.rup.qa.rfe.tests.domain.utils.PdfParser;
import com.copyright.rup.qa.rfe.tests.pages.PageFactory;
import com.copyright.rup.qa.rfe.tests.pages.SearchResultsPage;
import com.copyright.rup.qa.rfe.tests.utils.Constants;

import org.jbehave.core.annotations.BeforeScenario;
import org.jbehave.core.annotations.Then;
import org.jbehave.core.annotations.When;
import org.junit.Assert;
import org.slf4j.Logger;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.util.Arrays;
import java.util.List;

/**
 * Steps definition for Find Content.
 * @author Alexander_Kapitanov
 *
 */
public class SearchResultsSteps {
    
    private static final Logger LOGGER = RupLogUtils.getLogger();

    private final PageFactory pages;
    private SearchResultsPage page;
    
    private List<SearchResult> results;
    private int numberOfResults;
    private int searchResultsA;
    private int searchResultsB;
    private int searchResultsC;
    private int searchResultsAOrB;
    private int searchResultsAAndB;
    private int searchResultsAAndNotB;
    private int searchResultsAOrBOrC;
    private int searchResultsCAndAOrB;
    private int searchResultsAAndBOrC;
    private int searchResultsAOrBAndC;
    private int searchResultsAAndBAndC;
    private int searchResultsCAndNotAOrB;
    private int searchResultsCAndNotAAndB;

    /**
     * Constructor.
     * @param pages 
     */
    public SearchResultsSteps(PageFactory pages) {
        this.pages = pages;
    }
    
    /**
     * 
     */
    @BeforeScenario
    public void before() {
        page = pages.newSearchResultsPage();
    }
    
    /**
     * 
     * @param searchText 
     */
    @When("I enter free text \"$searchText\" to search field on Search Results page")
    public void whenIEnterTextBloodPressureToSearchField(String searchText) {
        page.setSearchField(searchText);
    }

    /**
     * 
     * @param resultsNumber 
     */
    @When("I get $resultsNumber search results")
    public void thenIGetSearchResults(int resultsNumber) {
        results = page.getSearchResultsFromCurrentPage();
        assertEquals("Incorrect number of search results", resultsNumber, results.size());
        
        int actualResultsNumber = page.getNumberOfSearchResults();
        assertEquals("Incorrect number of search results in title", resultsNumber, actualResultsNumber);
    }
    
    /**     */
    @Then("Citations not found")
    public void noResults() {
        results = page.getSearchResultsFromCurrentPage();
        assertEquals("Incorrect number of search results", 0, results.size());
    }
    
    /** */
    @Then("I get search results")
    public void thenIGetSearchResultsNotEmpty() {
        numberOfResults = page.getNumberOfSearchResults();
        thenSearchResultIsNotEmpty();
    }
    
    /** */
    @Then("Search result is not empty")
    public void thenSearchResultIsNotEmpty() {
        results = page.getSearchResultsFromCurrentPage();
        Assert.assertTrue("Search results are empty", results.size()!=0);
    }
    
    /**
     * Verifies that number of search results is the same as in previous search.
     */
    @Then("I got the same amount of results")
    public void thenIGotTheSameResultsAmount() {
        page.waitLoading();
        int currentNumberOfResults = page.getNumberOfSearchResults();
        Assert.assertEquals("I got wrong number of results", numberOfResults, currentNumberOfResults);
    }
    
    /**
     * Verifies that current number of results is less than remembered one.
     */
    @Then("I get less results than previous")
    public void iGetLessResults() {
        int currentNumberOfResults = page.getNumberOfSearchResults();
        boolean currentLessThanPrevious = currentNumberOfResults < numberOfResults;
        Assert.assertTrue("I got wrong number of results", currentLessThanPrevious);
    }
    
    /**
     * Click on first descriptor in vocabulary chart.
     */
    @When("I click on first vocabulary descriptor")
    public void clickOnFirstDescriptor() {
        page.clickFirstDescriptor();
        page.waitLoading();
    }
    
    /**
     * Clicks on first synonym in vocabulary chart.
     */
    @When("I click on first vocabulary synonym")
    public void clickOnFirstSynonym() {
        page.clickFirstSynonym();
        page.waitLoading();
    }
    
    /** @param resultTitle .
     */
    @Then("Search result contain title $resultTitle")
    public void checkResults(String resultTitle) {
        LOGGER.info("Check that result contains title: {}", resultTitle);
        boolean result = false;
        for (SearchResult res : results) {
            if (res.getTitle().toLowerCase().contains(resultTitle.toLowerCase())) {
                result = true;
                break;
            }
        }
        assertTrue("Search results don't contain: " + resultTitle, result);
    }
    
    /** @param resultTitle .
     */
    @Then("First search result contains $resultTitle")
    public void checkFirstResult(String resultTitle) {
        LOGGER.info("Check that result contains title: {}", resultTitle);
        String[] synonyms = resultTitle.split("|");
        boolean result = false;
        for (String synonym : synonyms) {
            if (results.get(0).getTitle().toLowerCase().contains(synonym.toLowerCase())) {
                result = true;
                break;
            }
        }
        assertTrue("Search results don't contain: " + resultTitle, result);
    }
    
    /**
     * Verifies that every search result title contains specific word or phrase.
     * @param resultKeyword .
     */
    @Then("Every search result contains word \"$resultKeyword\"")
    public void checkEveryResult(String resultKeyword) {
        LOGGER.info("Check that result contains title: {}", resultKeyword);
        boolean result = true;
        for (SearchResult res : results) {
            if (!res.getTitle().toLowerCase().contains(resultKeyword.toLowerCase())) {
                result = false;
                break;
            }
        }
        assertTrue("Some search results don't contain: " + resultKeyword, result);
    }
    
    /**
     * Verifies that every search result title contains one of the synonyms divided by commas.
     * @param resultKeyword .
     */
    @Then("Every search result contains one of the synonyms: \"$resultKeyword\"")
    public void checkEveryResultForSynonyms(String resultKeyword) {
        LOGGER.info("Check that result contains title: {}", resultKeyword);
        boolean everyCitationContainsSynonyms = true;
        for (SearchResult res : results) {
            boolean containsAnySynonym = false;
            for (String synonym : resultKeyword.split(",")) {
                if (res.getTitle().toLowerCase().contains(synonym.toLowerCase().trim())) {
                    containsAnySynonym = true;
                    break;
                }
            }
            if (!containsAnySynonym) {
                LOGGER.info("Title does not contain synonym: {}", res.getTitle());
            }
            everyCitationContainsSynonyms &= containsAnySynonym;
        }
        assertTrue("Some search results don't contain: " + resultKeyword, everyCitationContainsSynonyms);
    }

    /**
     * Compare title and button names for citation.
     * Expe
     * @param itemNumber 
     * @param resultTitle 
     * @param resultButtons 
     */
    @Then("Search results contain item #$itemNumber with title \"$resultTitle\" "
            + "and with available buttons $resultButtons")
    public void checkResults(int itemNumber, String resultTitle, String resultButtons) {
        LOGGER.info(String.format("Check that result contains item with number = %s, title = %s, buttons: %s",
                itemNumber, resultTitle, resultButtons));
        List<String> expectedButtonsList;

        expectedButtonsList = Arrays.asList(resultButtons.split(","));
        expectedButtonsList.replaceAll(String::trim);

        SearchResult actualSearchResult = results.get(itemNumber);

        assertEquals("Incorrect title", resultTitle, actualSearchResult.getTitle());
        assertTrue("Incorrect buttons", actualSearchResult.getButtons().containsAll(expectedButtonsList));
    }
    
    /**
     * 
     * @param buttonName .
     * @param itemIndex .
     */
    @When("I click $buttonName button for item #$itemIndex from search results")
    public void clickGetThisJournalItem(String buttonName, int itemIndex) {
        page.clickResultsItemButton(itemIndex, buttonName);        
    }
    
    /**
     * Finds button for item by Title.
     * @param buttonName .
     * @param titleText .
     */
    @When("I click $buttonName button for search result item with title: $titleText")
    public void clickSearchResultButtonByTitle(String buttonName, String titleText) {
        page.clickResultsItemButtonByTitle(titleText, buttonName);
    }
    
    /**
     * 
     * @param itemIndex 
     * @param expectedItc 
     */
    @Then("Search result #$itemIndex has catalogID = $catalogID"      )
    public void checkItc(int itemIndex, String expectedcatalogID) {
        String actualcatalogID = page.getSearchResultCitationParam(itemIndex, Constants.CATALOG_ID);
        Assert.assertEquals("Incorrect catalog ID for item #" + itemIndex, expectedcatalogID,  actualcatalogID);
    }
    /**
     */
    @When("I open Search History on Search Results page")
    public void openHistoryOptions() {
        page.openHistoryOptions();
    }

    /**
     */
    @Then("Search History opened on Search Results page")
    public void searchHistoryOpened() {
        page.searchHistory().isOpened();
    }
    
    /**
     * @param collection .
     */
    @When("I select $collection collection in Search Options")
    public void selectCollectionInOptions(String collection) {
        page.searchOptions().selectCollection(collection);
    }
    
    /**
     * @param library .
     */
    @When("I select $library library in Search Options")
    public void selectLibraryInOptions(String library) {
        page.searchOptions().selectLibrary(library);
    }
    
    /**Select certain previous search.
     * @param number .
     */
    @When("I select $number row in Previous Searches on Search Results page")
    public void choosePreviousSearch(int number) {
        page.searchHistory().previousSearches().select(number + 1);
        page.waitSearchLoading();
    }
        
        
    /**
     * 
     * @param itemName 
     */
    @When("I click on title of \"$itemName\" item in search results")
    public void clickItemTitle(String itemName) {
        Assert.assertTrue("Title link is not displayed for item name: " + itemName, 
            page.itemTitleLink(itemName).isDisplayed());
        page.itemTitleLink(itemName).click();
        page.waitLoading();
    }
    
    /**Checks results for matching. If results has wrong order, makes a debug message.*/
    @Then("Results of search are the same as previous")
    public void compareSearchResults() {
        page.waitLoading();
        if (results == null) {
            throw new RuntimeException("Results is null");
        }
        boolean equal = true;
        List<SearchResult> actualResults = page.getSearchResultsFromCurrentPage();
        for (int i = 0; i < results.size(); i++) {
            String expectedTitle = results.get(i).getTitle();
            boolean inActual = false;
            for (int j = 0; j < actualResults.size(); j++) {
                if (actualResults.get(j).getTitle().equals(expectedTitle)){
                    if (i != j) {
                        LOGGER.debug("WRONG ORDER!");
                    }
                    inActual = true;
                    break;
                }
            }
            if (inActual) {
                LOGGER.debug("{} IN THE LIST!", expectedTitle);
            } else {
                LOGGER.debug("NOT IN THE LIST!!!! {}", expectedTitle);
                equal = false;
            }
        }
        Assert.assertEquals("Search has found different number of results", 
            numberOfResults, page.getNumberOfSearchResults());
        Assert.assertTrue("Results aren't same", equal);
    }
    
    /**Opens Saved Searches combobox and selects last row "Manage Saved Searches".     */
    @When("I manage saved Searches")
    public void manageSavedSearches() {
        pages.newFindContentPage().searchHistory().savedSearches().click();
        pages.newFindContentPage().waitForAjax();
        pages.newFindContentPage().searchHistory().manageSavedSearchesButton().click();
        pages.newFindContentPage().waitLoading();
    }
    
    /**
     * @param searchValue 
     */
    @When("I perform search on Search Results page by value \"$searchValue\"")
    public void searchOnHomePage(String searchValue) {
        page.setSearchField(searchValue);
        page.searchButton().click();
    }
    

    /**
     * Adds new keyword to search box, selecting Semantic Search descriptor.
     * @param keyword .
     * @param descriptor .
     */
    @When("I add \"$keyword\" to search box and select \"$descriptor\" on Search Results page")
    public void addDescriptorByKeyword(String keyword, String descriptor) {
        page.selectKeyword(keyword, descriptor);
    }

    /**
     * 
     * @param index .
     */
    @When("I select citation #$index on Find Content Page")
    public void selectCitation(int index) {
        page.selectCitationCheckbox(index).set(true);
    }

    /**
     * Writes down number of search results.
     * @param operation .
     */
    @Then("I remember number of search results for $operation")
    public void rememberResult(String operation) {
        page.waitLoading();
        int currentNumberOfResults = page.getNumberOfSearchResults();
        setLogicOperationSearchResult(operation, currentNumberOfResults);
        Assert.assertTrue("Search results are empty!", currentNumberOfResults > 0);
    }
    
    /**
     * Compares two numbers of search results.
     * @param firstOperand .
     * @param condition .
     * @param secondOperand .
     */
    @Then("Result of $firstOperand is $condition than $secondOperand")
    public void verifyFirstLessThanSecond(String firstOperand, String condition, String secondOperand) {
        int firstResult = getLogicOperationSearchResult(firstOperand);
        int secondResult = getLogicOperationSearchResult(secondOperand);
        switch (condition) {
        case "less" :
            Assert.assertTrue("Second result is less than first", firstResult < secondResult);
            break;
        case "greater" :
            Assert.assertTrue("Second result is greater than first", firstResult > secondResult);
            break;
        default:
            Assert.fail("Unexpected argument of condition");
        }
    }
    
    /**
     * Verifies number of results for a query with logical operation.
     * @param operation .
     */
    @Then("I verify number of results for $operation")
    public void verifyLogicalOperationResult(String operation) {
        int expectedResult = 0;
        int actualResult = getLogicOperationSearchResult(operation);
        switch (operation) {
        case "A or B":
            expectedResult = getLogicOperationSearchResult("A") + getLogicOperationSearchResult("B") 
                                - getLogicOperationSearchResult("A and B");
            break;
        case "A or B or C":
            expectedResult = getLogicOperationSearchResult("A or B") + getLogicOperationSearchResult("C") 
                                - getLogicOperationSearchResult("A or B and C");
            break;
        case "A and not B":
            expectedResult = getLogicOperationSearchResult("A") - getLogicOperationSearchResult("A and B");
            break;
        case "C and not (A or B)":
            expectedResult = getLogicOperationSearchResult("C") - getLogicOperationSearchResult("C and (A or B)");
            break;
        case "C and not (A and B)":
            expectedResult = getLogicOperationSearchResult("C") - getLogicOperationSearchResult("A and B and C");
            break;
        default:
            Assert.fail("Unexpected argument of logical operation");
        }
        Assert.assertEquals("Number of search results if wrong", expectedResult, actualResult);
    }
    
    private int getLogicOperationSearchResult(String representation) {
        int resultsForOperation;
        switch (representation) {
        case "A":
            resultsForOperation = searchResultsA;
            break;
        case "B":
            resultsForOperation = searchResultsB;
            break;
        case "C":
            resultsForOperation = searchResultsC;
            break;
        case "A or B":
            resultsForOperation = searchResultsAOrB;
            break;
        case "A and B":
            resultsForOperation = searchResultsAAndB;
            break;
        case "A and not B":
            resultsForOperation = searchResultsAAndNotB;
            break;
        case "A or B or C":
            resultsForOperation = searchResultsAOrBOrC;
            break;
        case "A and B and C":
            resultsForOperation = searchResultsAAndBAndC;
            break;    
        case "A and B or C":
            resultsForOperation = searchResultsAAndBOrC;
            break;
        case "A or B and C":
            resultsForOperation = searchResultsAOrBAndC;
            break;
        case "C and (A or B)":
            resultsForOperation = searchResultsCAndAOrB;
            break;
        case "C and not (A or B)":
            resultsForOperation = searchResultsCAndNotAOrB;
            break;
        case "C and not (A and B)":
            resultsForOperation = searchResultsCAndNotAAndB;
            break;    
        default:
            resultsForOperation = 0;
        }
        return resultsForOperation;
    }
    
    private void setLogicOperationSearchResult(String representation, int resultsNumber) {
        switch (representation) {
        case "A":
            searchResultsA = resultsNumber;
            break;
        case "B":
            searchResultsB = resultsNumber;
            break;
        case "C":
            searchResultsC = resultsNumber;
            break;
        case "A or B":
            searchResultsAOrB = resultsNumber;
            break;
        case "A and B":
            searchResultsAAndB = resultsNumber;
            break;
        case "A and not B":
            searchResultsAAndNotB = resultsNumber;
            break;
        case "A or B or C":
            searchResultsAOrBOrC = resultsNumber;
            break;
        case "A and B and C":
            searchResultsAAndBAndC = resultsNumber;
            break;
        case "A and B or C":
            searchResultsAAndBOrC = resultsNumber;
            break;
        case "A or B and C":
            searchResultsAOrBAndC = resultsNumber;
            break;
        case "C and (A or B)":
            searchResultsCAndAOrB = resultsNumber;
            break;
        case "C and not (A or B)":
            searchResultsCAndNotAOrB = resultsNumber;
            break;
        case "C and not (A and B)":
            searchResultsCAndNotAAndB = resultsNumber;
            break;    
        default:
            Assert.fail("Unexpected argument as representation");
        }
    }
    
    /**
     * Click button from dropdown menu of option button.
     * @param optionLink 
     * @param option 
     */
    @When("On Search results page I click \"$optionLink\" button from \"$option\" menu")
    public void clickOptionLinkInMenu(String optionLink, String option) {
        page.selectOptionButton(option, optionLink);
    }
    
    /**
     * Goes to saved and shared search link.
     */
    @When("I directly go to saved search link")
    public void goToSharedSearchLink() {
        String url = page.sharedSearchResLink().getValue();
        UiSupport.open(url);
        page.waitPageLoading();
    }
    
    /**
     * Verifies number of found citations on page.
     * @param expectedCount 
     */
    @Then("There are $expectedCount search results on Shared Search Results page")
    public void verifySharedResultsCount(int expectedCount) {
        int actualCount = pages.newSharedSearchResultsPage().getNumberOfSearchResults();
        Assert.assertEquals("", expectedCount, actualCount);
    }
    
    /**
     * Downloads PDF document from sharable link on Search Results page.
     * @param filePathFromHome .
     * @throws IOException 
     * 
     */
    @When("I download PDF document from link on Search Results page to $address")
    public void downloadPdfDocument(String filePathFromHome) throws IOException {
        try {
            URL url = new URL(pages.newSearchResultsPage().sharedSearchResLink().getValue());
            FileOutputStream fos = new FileOutputStream(new File(System.getProperty("user.home") + filePathFromHome));
            ReadableByteChannel rbc = Channels.newChannel(url.openStream());
            fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
            fos.close();
        } catch (MalformedURLException e) {
            LOGGER.debug(e.toString());
        }
    }
    
    /**
     * Verifies certain condition of element in PDF document.
     * @param filePath .
     * @param elementName .
     * @param elementType .
     * @param conditionName .
     */
    @Then("In $filePath PDF document I verify that \"$elementName\" $elementType has condition \"$conditionName\"")
    public void verifyElementInPdf(String filePath, String elementName, String elementType, String conditionName) {
        switch (conditionName) {
        case "visible":
            Assert.assertTrue("Element is not visible: " + elementName, PdfParser.getPdfDocumentText(filePath)
                    .toLowerCase()
                    .contains(elementName.toLowerCase()));
            break;
        case "hidden":
            Assert.assertFalse("Element is visible: "+ elementName, PdfParser.getPdfDocumentText(filePath)
                    .toLowerCase()
                    .contains(elementName.toLowerCase()));
            break;
        default:
            throw new RuntimeException("Unknown condition: " + conditionName);
        }
    }
    
    /**
     * Verifies the number of search results in downloaded PDF document.
     * @param numberOfResultsFromFile .
     * @param filePathFromHome .
     */
    @Then("There are $numberOfResults number of results from $address PDF document")
    public void iGetNumberOfPages(int numberOfResultsFromFile, String filePathFromHome) {
        Assert.assertEquals(numberOfResultsFromFile, PdfParser.getLinksFromPdfDocument(filePathFromHome).size()-1);
    }
    
    /**
     * Clicking get content for the specified result from PDF document.
     * @param numberOfResult .
     * @param filePathFromHome .
     */
    @When("I click Get Content link for $numberOfResult result in PDF document from $address PDF document")
    public void iClickGetContentForResultInPdfDocument(int numberOfResult, String filePathFromHome) {
        String url = PdfParser.getLinksFromPdfDocument(filePathFromHome).get(numberOfResult);
        UiSupport.open(url);
        LOGGER.debug("Opening URL: {}", url);
        pages.newMainPage().waitLoading();
    }
    
    /**
     * Clicking Re-run link from PDF document.
     * @param filePathFromHome .
     */
    @When("I click Re-run link in PDF document from $address")
    public void iClickRerunLinkFromPdfDocument(String filePathFromHome) {
        String url = PdfParser.getLinksFromPdfDocument(filePathFromHome).get(0);
        UiSupport.open(url);
        LOGGER.debug("Opening URL: {}", url);
        pages.newMainPage().waitLoading();
    }
}   
